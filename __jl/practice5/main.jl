# Быстрое возведение в степень
function bin_pow(x::Integer, pow::Integer, mod::Integer)
    
    result = 1
    
    while ( pow > 0 ) 

        if (pow % 2 == 1)
            result = ( result * x ) % mod # вычитаем из стпени 1
            # чтобы на следующем шаге поделить показатель на 2
        end

        x = ( x * x ) % mod # делим показатель степени на 2

        pow = ( pow ÷ 2 )

    end


    return result
end

print( bin_pow(2, 130, 1000*1000*1000 + 7) )



# Алгоритм вычисления функции log_a(x)

# Поскольку нам придется работать с арифметикой с плавающей
# точкоq, то ни о каких точных значениях говорить не приходится.
# Поэтому будем вычислять значение функции с некоторой 
# погрешностью. Тогда если f(x) - искомое значение функции
# log_a(x), то для успеха необходимо, чтобы выполнялось
# неравенство abs( f(x) - log_a(x) ) <= eps.
# Понятно, что из уравнения f(x) = log_a(x) получим
# x = a^f(x) или поскольку rf(x) = f(x) + eps, где 
# rf(x) - абсолютно точное решение, получим 
# x = a^f(x) = a^(rf(x) + eps) = a^rf(x) * a^eps.

# Представим множитель a^eps как z^t и наконец получим
# eps = t * log_a(z). Теперь abs(t) <= eps и abs(log_a(z)) <= 1,
# приняв равенство abs(t) <= eps, из второго неравенства 
# следует 1/a <= z <= a. Т.е. задача заключается в подборе z.

function log(base, x) # log_(base)(x) = ?
    
    z = x
    t = 1
    f = 0
    
    
    while ( z > base || z < 1/base || t > 1e-8 ) # t > eps(Float64)

        if ( z < 1\base )
            z *= base
            f -= t
        elseif ( z > base )
            z /= base
            f += t
        else
            t /= 2
            z *= z
        end
    end


    return f
end

# ПОЧЕМУ??
# ----------------------------
# Если в условии while ( z < 1/base || z > base || t > eps(Float64) )
# в качестве первой проверки поставить условие t > eps(Float64), то цикл
# никогда не остановиться. Это связано с тем, что 
# ----------------------------


# Решение нелинейного уравнения методом деления отрезка пополам
# Идея:
#     1. поделить отрезок пополам и сравнить значения функции в левой 
#        и правой окрестностях середины отрезка. Если значения имеют
#        один и тот же знак, то корень в другой части отрезка.
#     2. необходимо выполнять пункт 1 пока длинна отрезка больше чем
#        эпсилон

function _solve(f::Function, leftBorder, rightBorder)
    
    a = leftBorder
    b = rightBorder

    while ( (b - a) > eps(Float64) ) 
        middle = (b + a) / 2
        fx = f(middle) # т.к. вычисление f(x) может быть затратно
        if ( fx == 0 )
            
            
            return middle
        elseif ( fx * f(a) > 0)
            a = middle
        else
            b = middle
        end
    end


    return ( a + b ) / 2
end

# Алгоритм Евклида
# Алгоритм Евклида основан на том, что 
# gcd(a, b) = gcd(a%b, b)
function gcd(x::Integer, y::Integer)::Integer
    
    while (x > 0 && y > 0)

        if (x > y)
            x = x % y
        else 
            y = y % x
        end

    end


    return (x + y)
end

# a = t*b + r, если у a и b есть общие делители, то
# они обязательно являюется делителями числа r


# Расширенный алгоритм Евклида
# ax + by = (a,b) - это уравнение всегда имеет решение
# Почему? Потому что мы знаем, что уравнение вида 
# ax + by = 1 при (a,b) = 1 (*) всегда имеет решение. Тогда
# если в первом уравнении (a,b) = 1, то оно имеет решение 
# из-за (*), но если (a,b) != 1, то разделив обе части
# исходного уравнения на (a,b) сведем его к (*), останется
# только решение (*) домножить на (a,b).

# Элемент inv называется обратным к элементу a в кольце по
# модулю n, если a*inv = 1 или a*inv = 1 + n*cat

# a*inv = 1 + n*c <=>
# a*inv - n*c = 1 <=>
# a*inv + n*(-c) = 1

# Расширенный Алгоритм Евклида сводится к следующей идеи:
#     1. (a, b) = ( m( =a ), n( =b ) ) 
#     2. a = xa * m + ya * n
#        b = xb * m + yb * n
#     3. (a, b) = (a, b%a)  т.е.
#        (b, b%a) = ( m( =a ), n( =b ) )

#        но (b%a) = a - b*(a÷b) = (xa - xb*k)m + (ya - yb*k)n
#     4. в тот момент, когда b(new) станет равным 0, 
#        a будет равняться (a,b).
#     5. В итоге, если a(new) = 1, то xa есть коэффициент в уравнении
#        a*xa + b*xb = (a,b) т.е. a * xa + 0 = 1, а значит, что 
#        xa - обратный элемент к a 
function gcdEx(a::Integer, b::Integer)::Integer
    m,n = a,b

    xa, ya = 1, 0
    xb, yb = 0, 1
    
    while ( n != 0 )
        k = (m ÷ n)

        m, n = n, (m % n)

        x,y = xa, ya
        xa, ya = xb, yb
        xb, yb = x - xb*k, y - yb*k
    
    end
    
    (m != 1) && return m
    
    
    return xa
end
